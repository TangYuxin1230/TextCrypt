<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TextCrypt - 多功能加密解密工具</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --container-bg: white;
            --text-color: #333;
            --border-color: #ddd;
            --tab-bg: #f8f9fa;
            --tab-active-bg: white;
            --button-primary: #007bff;
            --button-primary-hover: #0056b3;
            --button-secondary: #6c757d;
            --button-secondary-hover: #545b62;
            --button-success: #28a745;
            --button-success-hover: #218838;
            --button-warning: #ffc107;
            --button-warning-hover: #e0a800;
            --button-info: #17a2b8;
            --button-info-hover: #138496;
            --error-color: #dc3545;
            --success-color: #28a745;
            --info-bg: #d1ecf1;
            --info-border: #bee5eb;
            --warning-bg: #fff3cd;
            --warning-border: #ffeaa7;
            --note-bg: #e9ecef;
            
            /* 新增的VP样式变量 */
            --vp-c-text-mute: rgba(60, 60, 67, .78);
            --vp-c-text: rgb(60, 60, 67);
            --vp-t-color: .3s ease;
        }

        .dark-mode {
            --bg-color: #121212;
            --container-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --border-color: #444;
            --tab-bg: #2d2d2d;
            --tab-active-bg: #1e1e1e;
            --button-primary: #3a86ff;
            --button-primary-hover: #5a96ff;
            --button-secondary: #555555;
            --button-secondary-hover: #666666;
            --button-success: #2a9d8f;
            --button-success-hover: #3aab9f;
            --button-warning: #e9c46a;
            --button-warning-hover: #f4d18a;
            --button-info: #264653;
            --button-info-hover: #365663;
            --error-color: #e76f51;
            --success-color: #2a9d8f;
            --info-bg: #264653;
            --info-border: #365663;
            --warning-bg: #e9c46a;
            --warning-border: #f4d18a;
            --note-bg: #264653;
            
            /* 深色模式下的VP样式变量 */
            --vp-c-text-mute: rgba(224, 224, 224, .78);
            --vp-c-text: rgb(224, 224, 224);
        }

        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 15px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.5s cubic-bezier(0.4, 0, 0.2, 1), color 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.theme-transition * {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1) !important;
        }
        .container {
            background-color: var(--container-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: background-color 0.5s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        h1 {
            text-align: center;
            color: var(--text-color);
            font-size: 1.5em;
            margin-top: 0;
            display: inline-block;
            transition: color 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .vp-color-mode-switch {
            -webkit-font-smoothing: antialiased;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            text-size-adjust: none;
            white-space: nowrap;
            border: 2px solid var(--border-color);
            background: var(--container-bg);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            vertical-align: middle;
            padding: 8px;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            float: right;
            border-radius: 50%;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .vp-color-mode-switch::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--button-primary);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: -1;
            border-radius: 50%;
        }
        .vp-color-mode-switch:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            border-color: var(--button-primary);
        }
        .vp-color-mode-switch:hover::before {
            opacity: 0.1;
        }
        .vp-color-mode-switch:active {
            transform: scale(0.92);
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }
        .vp-color-mode-switch svg {
            transition: transform 0.3s ease;
        }
        .vp-color-mode-switch:hover svg {
            transform: rotate(15deg);
        }
        .tabs {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: var(--tab-bg);
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            font-size: 0.9em;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .tab.active {
            background-color: var(--tab-active-bg);
            border-bottom: 1px solid var(--tab-active-bg);
            margin-bottom: -1px;
            color: var(--button-primary);
            font-weight: bold;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
            color: var(--text-color);
            transition: color 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        textarea {
            width: 100%;
            height: 120px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            resize: vertical;
            box-sizing: border-box;
            font-size: 0.9em;
            background-color: var(--container-bg);
            color: var(--text-color);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9em;
            background-color: var(--container-bg);
            color: var(--text-color);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        button {
            padding: 8px 16px;
            background-color: var(--button-primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
            min-width: 100px;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: var(--button-primary-hover);
        }
        .clear-btn {
            background-color: var(--button-secondary);
        }
        .clear-btn:hover {
            background-color: var(--button-secondary-hover);
        }
        .generate-btn {
            background-color: var(--button-success);
        }
        .generate-btn:hover {
            background-color: var(--button-success-hover);
        }
        .key-btn {
            background-color: var(--button-warning);
            color: #212529;
        }
        .key-btn:hover {
            background-color: var(--button-warning-hover);
        }
        .encode-btn {
            background-color: var(--button-info);
        }
        .encode-btn:hover {
            background-color: var(--button-info-hover);
        }
        .error {
            color: var(--error-color);
            margin: 10px 0;
            font-size: 0.9em;
            transition: color 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .success {
            color: var(--success-color);
            margin: 10px 0;
            font-size: 0.9em;
            transition: color 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .key-modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
            overflow-y: auto;
            transition: background-color 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .key-modal-content {
            background-color: var(--container-bg);
            margin: 10% auto;
            padding: 15px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 500px;
            border-radius: 5px;
            color: var(--text-color);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .close {
            color: var(--text-color);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .close:hover {
            color: var(--button-primary);
        }
        .close:hover {
            color: var(--button-primary);
        }
        .instructions {
            background-color: var(--note-bg);
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9em;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .file-info {
            background-color: var(--info-bg);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 0.9em;
            border: 1px solid var(--info-border);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .note {
            background-color: var(--warning-bg);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid var(--warning-border);
            font-size: 0.9em;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .drop-zone {
            border: 2px dashed var(--button-primary);
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            background-color: var(--tab-bg);
        }
        .drop-zone:hover {
            background-color: var(--note-bg);
        }
        .drop-zone.drag-over {
            background-color: #cce5ff;
        }
        .dark-mode .drop-zone.drag-over {
            background-color: #0d4a85;
        }
        .copy-btn {
            padding: 6px 12px;
            background-color: var(--button-success);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-top: 6px;
            transition: background-color 0.2s ease;
        }
        .copy-btn:hover {
            background-color: var(--button-success-hover);
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 10px;
            }
            .tabs {
                flex-direction: row;
                overflow-x: auto;
            }
            .tab {
                white-space: nowrap;
                padding: 8px 12px;
                font-size: 0.85em;
            }
            .button-group {
                flex-direction: column;
            }
            button {
                width: 100%;
                margin-bottom: 5px;
                padding: 10px;
                font-size: 1em;
            }
            .key-modal-content {
                width: 95%;
                margin: 5% auto;
                padding: 12px;
            }
            textarea {
                height: 100px;
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 1.3em;
            }
            .tab {
                padding: 6px 10px;
                font-size: 0.8em;
            }
            .button-group {
                gap: 5px;
            }
            button {
                padding: 8px;
                font-size: 0.9em;
            }
            .key-modal-content {
                width: 98%;
                margin: 2% auto;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TextCrypt - 多功能加密解密工具</h1>
        <button type="button" class="vp-color-mode-switch" id="color-mode-switch" title="切换深浅色模式">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;width:20px;height:20px;">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:block;width:20px;height:20px;">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
        
        <div class="instructions">
            <p><strong>功能说明：</strong></p>
            <ul>
                <li>文本加密/解密（AES-GCM算法）</li>
                <li>Base64编码/解码</li>
                <li>文件加密/解密</li>
                <li>MD5/SHA256哈希计算</li>
            </ul>
        </div>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('text')">文本加密</div>
            <div class="tab" onclick="switchTab('base64')">Base64编码</div>
            <div class="tab" onclick="switchTab('file')">文件加密</div>
            <div class="tab" onclick="switchTab('hash')">哈希计算</div>
        </div>
        
        <!-- 文本加密/解密 -->
        <div id="text-tab" class="tab-content active">
            <div class="input-group">
                <label for="inputText">输入文本:</label>
                <textarea id="inputText" placeholder="请输入要加密或解密的文本..."></textarea>
            </div>
            
            <div class="button-group">
                <button onclick="encryptText()">加密文本</button>
                <button onclick="decryptText()">解密文本</button>
                <button class="clear-btn" onclick="clearTextTab()">清空</button>
                <button class="generate-btn" onclick="generateKey()">生成新密钥</button>
                <button class="key-btn" onclick="showKey()">显示密钥</button>
            </div>
            
            <div class="input-group">
                <label for="outputText">输出文本:</label>
                <textarea id="outputText" placeholder="结果将显示在这里..." readonly></textarea>
                <button onclick="copyToClipboard('outputText')" class="copy-btn">复制结果</button>
            </div>
        </div>
        
        <!-- Base64编码/解码 -->
        <div id="base64-tab" class="tab-content">
            <div class="input-group">
                <label for="inputBase64">输入文本:</label>
                <textarea id="inputBase64" placeholder="请输入要编码或解码的文本..."></textarea>
            </div>
            
            <div class="button-group">
                <button class="encode-btn" onclick="encodeBase64()">Base64编码</button>
                <button class="encode-btn" onclick="decodeBase64()">Base64解码</button>
                <button class="clear-btn" onclick="clearBase64Tab()">清空</button>
            </div>
            
            <div class="input-group">
                <label for="outputBase64">输出文本:</label>
                <textarea id="outputBase64" placeholder="结果将显示在这里..." readonly></textarea>
                <button onclick="copyToClipboard('outputBase64')" class="copy-btn">复制结果</button>
            </div>
        </div>
        
        <!-- 文件加密/解密 -->
        <div id="file-tab" class="tab-content">
            <div class="input-group">
                <label for="fileInput">选择文件:</label>
                <div id="dropZone" class="drop-zone">
                    <input type="file" id="fileInput" style="display: none;">
                    <div id="dropZoneText">将文件拖拽到此处或点击选择文件</div>
                </div>
            </div>
            
            <div class="file-info" id="fileInfo">
                请先选择一个文件
            </div>
            
            <div class="button-group">
                <button onclick="encryptFile()">加密文件</button>
                <button onclick="decryptFile()">解密文件</button>
                <button class="clear-btn" onclick="clearFileTab()">清空</button>
            </div>
            
            <div class="input-group">
                <label for="outputFile">输出文件:</label>
                <textarea id="outputFile" placeholder="文件处理结果信息..." readonly></textarea>
                <button onclick="copyToClipboard('outputFile')" class="copy-btn">复制结果</button>
            </div>
            
            <div id="downloadLink"></div>
        </div>
        
        <!-- 哈希计算 -->
        <div id="hash-tab" class="tab-content">
            <div class="note">
                <strong>注意：</strong>哈希算法是单向的，用于生成数据的"指纹"，无法解密。相同输入总是产生相同输出，但无法从输出推导出原始输入。
            </div>
            
            <div class="input-group">
                <label for="inputHash">输入文本:</label>
                <textarea id="inputHash" placeholder="请输入要计算哈希的文本..."></textarea>
            </div>
            
            <div class="button-group">
                <button onclick="calculateMD5()">计算MD5</button>
                <button onclick="calculateSHA256()">计算SHA256</button>
                <button onclick="findHash()">尝试查找</button>
                <button class="clear-btn" onclick="clearHashTab()">清空</button>
            </div>
            
            <div class="input-group">
                <label for="outputHash">哈希结果:</label>
                <textarea id="outputHash" placeholder="哈希结果将显示在这里..." readonly></textarea>
                <button onclick="copyToClipboard('outputHash')" class="copy-btn">复制结果</button>
            </div>
            
            <div class="note">
                <strong>关于哈希解密：</strong>哈希算法是单向函数，无法直接"解密"。但可以通过彩虹表查找或暴力破解尝试找到原始输入。这些方法不是真正的解密，而是尝试匹配已知的哈希值。
            </div>
        </div>
        
        <div id="message"></div>
    </div>
    
    <!-- 密钥显示模态框 -->
    <div id="keyModal" class="key-modal">
        <div class="key-modal-content">
            <span class="close" onclick="closeKeyModal()">×</span>
            <h2>当前密钥</h2>
            <textarea id="keyText" readonly></textarea>
            <div class="button-group">
                <button onclick="copyKey()">复制密钥</button>
                <button onclick="saveKeyToFile()">保存密钥到文件</button>
                <button onclick="loadKeyFromFile()">从文件加载密钥</button>
            </div>
            <div class="input-group">
                <label for="importKey">或粘贴密钥:</label>
                <textarea id="importKey" placeholder="在此粘贴您的密钥..."></textarea>
                <button onclick="importKey()">导入密钥</button>
            </div>
        </div>
    </div>
    
    <script>
        // 深色模式功能
        function initDarkMode() {
            const colorModeSwitch = document.getElementById('color-mode-switch');
            const darkIcon = document.querySelector('.dark-icon');
            const lightIcon = document.querySelector('.light-icon');
            
            // 检查保存的模式
            const savedMode = localStorage.getItem('colorMode');
            
            // 设置初始状态
            if (savedMode) {
                if (savedMode === 'dark') {
                    document.body.classList.add('dark-mode');
                    darkIcon.style.display = 'block';
                    lightIcon.style.display = 'none';
                } else {
                    document.body.classList.remove('dark-mode');
                    darkIcon.style.display = 'none';
                    lightIcon.style.display = 'block';
                }
            } else {
                // 默认浅色模式
                document.body.classList.remove('dark-mode');
                darkIcon.style.display = 'none';
                lightIcon.style.display = 'block';
            }
            
            // 切换按钮点击事件
            colorModeSwitch.addEventListener('click', () => {
                // 添加切换动画类
                document.body.classList.add('theme-transition');
                
                const isDarkMode = document.body.classList.contains('dark-mode');
                
                if (isDarkMode) {
                    // 从深色模式切换到浅色模式
                    document.body.classList.remove('dark-mode');
                    localStorage.setItem('colorMode', 'light');
                    darkIcon.style.display = 'none';
                    lightIcon.style.display = 'block';
                } else {
                    // 从浅色模式切换到深色模式
                    document.body.classList.add('dark-mode');
                    localStorage.setItem('colorMode', 'dark');
                    darkIcon.style.display = 'block';
                    lightIcon.style.display = 'none';
                }
                
                // 移除过渡类以避免影响其他样式
                setTimeout(() => {
                    document.body.classList.remove('theme-transition');
                }, 500);
            });
        }
        
        // 初始化密钥
        function initKey() {
            let key = localStorage.getItem('textCryptKey');
            if (!key) {
                key = generateRandomKey();
                localStorage.setItem('textCryptKey', key);
            }
            return key;
        }
        
        // 生成随机密钥
        function generateRandomKey() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        }
        
        // 获取当前密钥
        function getCurrentKey() {
            return localStorage.getItem('textCryptKey') || initKey();
        }
        
        // 切换标签页
        function switchTab(tabName) {
            // 隐藏所有标签页内容
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 移除所有标签页的活动状态
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示选中的标签页
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // 设置选中标签页的活动状态
            event.target.classList.add('active');
        }
        
        // ==================== 文本加密/解密功能 ====================
        // 加密文本
        async function encryptText() {
            const inputText = document.getElementById('inputText').value.trim();
            if (!inputText) {
                showMessage('请输入要加密的文本!', 'error');
                return;
            }
            
            try {
                const key = getCurrentKey();
                const encrypted = await encrypt(inputText, key);
                document.getElementById('outputText').value = encrypted;
                showMessage('文本加密成功!', 'success');
            } catch (error) {
                showMessage('加密失败: ' + error.message, 'error');
            }
        }
        
        // 解密文本
        async function decryptText() {
            const inputText = document.getElementById('inputText').value.trim();
            if (!inputText) {
                showMessage('请输入要解密的文本!', 'error');
                return;
            }
            
            try {
                const key = getCurrentKey();
                const decrypted = await decrypt(inputText, key);
                document.getElementById('outputText').value = decrypted;
                showMessage('文本解密成功!', 'success');
            } catch (error) {
                showMessage('解密失败: ' + error.message, 'error');
            }
        }
        
        // 清空文本标签页
        function clearTextTab() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            document.getElementById('message').innerHTML = '';
        }
        
        // ==================== Base64编码/解码功能 ====================
        // Base64编码
        function encodeBase64() {
            const inputText = document.getElementById('inputBase64').value.trim();
            if (!inputText) {
                showMessage('请输入要编码的文本!', 'error');
                return;
            }
            
            try {
                const encoded = btoa(unescape(encodeURIComponent(inputText)));
                document.getElementById('outputBase64').value = encoded;
                showMessage('Base64编码成功!', 'success');
            } catch (error) {
                showMessage('编码失败: ' + error.message, 'error');
            }
        }
        
        // Base64解码
        function decodeBase64() {
            const inputText = document.getElementById('inputBase64').value.trim();
            if (!inputText) {
                showMessage('请输入要解码的Base64文本!', 'error');
                return;
            }
            
            try {
                const decoded = decodeURIComponent(escape(atob(inputText)));
                document.getElementById('outputBase64').value = decoded;
                showMessage('Base64解码成功!', 'success');
            } catch (error) {
                showMessage('解码失败: ' + error.message, 'error');
            }
        }
        
        // 清空Base64标签页
        function clearBase64Tab() {
            document.getElementById('inputBase64').value = '';
            document.getElementById('outputBase64').value = '';
            document.getElementById('message').innerHTML = '';
        }
        
        // ==================== 文件加密/解密功能 ====================
        // 文件选择事件处理
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                document.getElementById('fileInfo').innerHTML = 
                    `<strong>文件名:</strong> ${file.name}<br>
                     <strong>大小:</strong> ${formatFileSize(file.size)}<br>
                     <strong>类型:</strong> ${file.type || '未知'}`;
            } else {
                document.getElementById('fileInfo').innerHTML = '请先选择一个文件';
            }
        });
        
        // 拖拽功能初始化
        function initDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const dropZoneText = document.getElementById('dropZoneText');
            
            // 点击区域选择文件
            dropZone.addEventListener('click', () => {
                fileInput.click();
            });
            
            // 拖拽事件处理
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });
            
            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length) {
                    // 将文件分配给隐藏的文件输入元素
                    fileInput.files = files;
                    // 触发change事件
                    const event = new Event('change', { bubbles: true });
                    fileInput.dispatchEvent(event);
                }
            });
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        // 加密文件
        async function encryptFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showMessage('请先选择一个文件!', 'error');
                return;
            }
            
            try {
                // 读取文件内容
                const fileContent = await readFileAsArrayBuffer(file);
                
                // 加密文件内容
                const key = getCurrentKey();
                const encrypted = await encryptArrayBuffer(fileContent, key);
                
                // 创建下载链接
                const blob = new Blob([encrypted], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const filename = file.name + '.encrypted';
                
                // 显示结果信息
                document.getElementById('outputFile').value = 
                    `文件加密成功!\n原文件: ${file.name}\n加密文件: ${filename}\n大小: ${formatFileSize(encrypted.byteLength)}`;
                
                // 创建下载链接
                createDownloadLink(url, filename);
                
                showMessage('文件加密成功!', 'success');
            } catch (error) {
                showMessage('文件加密失败: ' + error.message, 'error');
            }
        }
        
        // 解密文件
        async function decryptFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showMessage('请先选择一个文件!', 'error');
                return;
            }
            
            if (!file.name.endsWith('.encrypted')) {
                showMessage('请选择一个加密文件 (.encrypted)!', 'error');
                return;
            }
            
            try {
                // 读取文件内容
                const fileContent = await readFileAsArrayBuffer(file);
                
                // 解密文件内容
                const key = getCurrentKey();
                const decrypted = await decryptArrayBuffer(fileContent, key);
                
                // 创建下载链接
                const blob = new Blob([decrypted], { type: 'application/octet-stream' });
                const originalName = file.name.replace('.encrypted', '');
                const url = URL.createObjectURL(blob);
                
                // 显示结果信息
                document.getElementById('outputFile').value = 
                    `文件解密成功!\n加密文件: ${file.name}\n原文件: ${originalName}\n大小: ${formatFileSize(decrypted.byteLength)}`;
                
                // 创建下载链接
                createDownloadLink(url, originalName);
                
                showMessage('文件解密成功!', 'success');
            } catch (error) {
                showMessage('文件解密失败: ' + error.message, 'error');
            }
        }
        
        // 读取文件为 ArrayBuffer
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(event.target.result);
                reader.onerror = error => reject(error);
                reader.readAsArrayBuffer(file);
            });
        }
        
        // 创建下载链接
        function createDownloadLink(url, filename) {
            const downloadDiv = document.getElementById('downloadLink');
            downloadDiv.innerHTML = `
                <div class="input-group">
                    <a href="${url}" download="${filename}" class="button">
                        <button style="width:100%">下载处理后的文件</button>
                    </a>
                </div>
            `;
        }
        
        // 清空文件标签页
        function clearFileTab() {
            document.getElementById('fileInput').value = '';
            document.getElementById('fileInfo').innerHTML = '请先选择一个文件';
            document.getElementById('outputFile').value = '';
            document.getElementById('downloadLink').innerHTML = '';
            document.getElementById('message').innerHTML = '';
        }
        
        // ==================== 哈希计算功能 ====================
        // 计算MD5哈希
        function calculateMD5() {
            const inputText = document.getElementById('inputHash').value.trim();
            if (!inputText) {
                showMessage('请输入要计算哈希的文本!', 'error');
                return;
            }
            
            try {
                const hash = md5(inputText);
                document.getElementById('outputHash').value = hash;
                showMessage('MD5哈希计算成功!', 'success');
            } catch (error) {
                showMessage('MD5哈希计算失败: ' + error.message, 'error');
            }
        }
        
        // 计算SHA256哈希
        async function calculateSHA256() {
            const inputText = document.getElementById('inputHash').value.trim();
            if (!inputText) {
                showMessage('请输入要计算哈希的文本!', 'error');
                return;
            }
            
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(inputText);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                document.getElementById('outputHash').value = hashHex;
                showMessage('SHA256哈希计算成功!', 'success');
            } catch (error) {
                showMessage('SHA256哈希计算失败: ' + error.message, 'error');
            }
        }
        
        // 哈希查找（模拟彩虹表查找）
        function findHash() {
            const hashValue = document.getElementById('outputHash').value.trim();
            if (!hashValue) {
                showMessage('请先计算一个哈希值!', 'error');
                return;
            }
            
            // 显示查找中消息
            showMessage('正在尝试查找哈希值对应的原始文本...', 'success');
            
            // 模拟查找过程
            setTimeout(() => {
                // 这里只是一个示例，实际应用中可以连接到彩虹表数据库
                // 或使用更复杂的破解算法
                const rainbowTable = {
                    "e10adc3949ba59abbe56e057f20f883e": "123456",
                    "25f9e794323b453885f5181f1b624d0b": "123456789",
                    "827ccb0eea8a706c4c34a16891f84e7b": "12345",
                    "fcea920f7412b5da7be0cf42b8c93759": "1234567",
                    "7c4a8d09ca3762af61e59520943dc264": "12345678",
                    "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8": "password",
                    "a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3": "123456",
                    "ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f": "123456789",
                    "e99a18c428cb38d5f260853678922e03": "abc123"
                };
                
                const found = rainbowTable[hashValue];
                if (found) {
                    document.getElementById('inputHash').value = found;
                    showMessage(`找到匹配的文本: ${found}`, 'success');
                } else {
                    showMessage('未在彩虹表中找到匹配的文本。哈希算法是单向的，无法直接解密。', 'error');
                }
            }, 1000);
        }
        
        // 清空哈希标签页
        function clearHashTab() {
            document.getElementById('inputHash').value = '';
            document.getElementById('outputHash').value = '';
            document.getElementById('message').innerHTML = '';
        }
        
        // ==================== MD5实现 ====================
        // MD5算法实现
        function md5(string) {
            function md5_RotateLeft(lValue, iShiftBits) {
                return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
            }
            
            function md5_AddUnsigned(lX, lY) {
                var lX4, lY4, lX8, lY8, lResult;
                lX8 = (lX & 0x80000000);
                lY8 = (lY & 0x80000000);
                lX4 = (lX & 0x40000000);
                lY4 = (lY & 0x40000000);
                lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
                if (lX4 & lY4) {
                    return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
                }
                if (lX4 | lY4) {
                    if (lResult & 0x40000000) {
                        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                    } else {
                        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                    }
                } else {
                    return (lResult ^ lX8 ^ lY8);
                }
            }
            
            function md5_F(x, y, z) { return (x & y) | ((~x) & z); }
            function md5_G(x, y, z) { return (x & z) | (y & (~z)); }
            function md5_H(x, y, z) { return (x ^ y ^ z); }
            function md5_I(x, y, z) { return (y ^ (x | (~z))); }
            
            function md5_FF(a, b, c, d, x, s, ac) {
                a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_F(b, c, d), x), ac));
                return md5_AddUnsigned(md5_RotateLeft(a, s), b);
            }
            
            function md5_GG(a, b, c, d, x, s, ac) {
                a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_G(b, c, d), x), ac));
                return md5_AddUnsigned(md5_RotateLeft(a, s), b);
            }
            
            function md5_HH(a, b, c, d, x, s, ac) {
                a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_H(b, c, d), x), ac));
                return md5_AddUnsigned(md5_RotateLeft(a, s), b);
            }
            
            function md5_II(a, b, c, d, x, s, ac) {
                a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_I(b, c, d), x), ac));
                return md5_AddUnsigned(md5_RotateLeft(a, s), b);
            }
            
            function md5_ConvertToWordArray(string) {
                var lWordCount;
                var lMessageLength = string.length;
                var lNumberOfWords_temp1 = lMessageLength + 8;
                var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
                var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
                var lWordArray = Array(lNumberOfWords - 1);
                var lBytePosition = 0;
                var lByteCount = 0;
                while (lByteCount < lMessageLength) {
                    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                    lBytePosition = (lByteCount % 4) * 8;
                    lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
                    lByteCount++;
                }
                lWordCount = (lByteCount - (lByteCount % 4)) / 4;
                lBytePosition = (lByteCount % 4) * 8;
                lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
                lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
                lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
                return lWordArray;
            }
            
            function md5_WordToHex(lValue) {
                var WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
                for (lCount = 0; lCount <= 3; lCount++) {
                    lByte = (lValue >>> (lCount * 8)) & 255;
                    WordToHexValue_temp = "0" + lByte.toString(16);
                    WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
                }
                return WordToHexValue;
            }
            
            function md5_Utf8Encode(string) {
                string = string.replace(/\r\n/g, "\n");
                var utftext = "";
                for (var n = 0; n < string.length; n++) {
                    var c = string.charCodeAt(n);
                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    } else if ((c > 127) && (c < 2048)) {
                        utftext += String.fromCharCode((c >> 6) | 192);
                        utftext += String.fromCharCode((c & 63) | 128);
                    } else {
                        utftext += String.fromCharCode((c >> 12) | 224);
                        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                        utftext += String.fromCharCode((c & 63) | 128);
                    }
                }
                return utftext;
            }
            
            var x = Array();
            var k, AA, BB, CC, DD, a, b, c, d;
            var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
            var S21 = 5, S22 = 9, S23 = 14, S24 = 20;
            var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
            var S41 = 6, S42 = 10, S43 = 15, S44 = 21;
            
            string = md5_Utf8Encode(string);
            x = md5_ConvertToWordArray(string);
            a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;
            
            for (k = 0; k < x.length; k += 16) {
                AA = a; BB = b; CC = c; DD = d;
                a = md5_FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
                d = md5_FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
                c = md5_FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
                b = md5_FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
                a = md5_FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
                d = md5_FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
                c = md5_FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
                b = md5_FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
                a = md5_FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
                d = md5_FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
                c = md5_FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
                b = md5_FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
                a = md5_FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
                d = md5_FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
                c = md5_FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
                b = md5_FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
                a = md5_GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
                d = md5_GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
                c = md5_GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
                b = md5_GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
                a = md5_GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
                d = md5_GG(d, a, b, c, x[k + 10], S22, 0x2441453);
                c = md5_GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
                b = md5_GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
                a = md5_GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
                d = md5_GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
                c = md5_GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
                b = md5_GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
                a = md5_GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
                d = md5_GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
                c = md5_GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
                b = md5_GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
                a = md5_HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
                d = md5_HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
                c = md5_HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
                b = md5_HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
                a = md5_HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
                d = md5_HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
                c = md5_HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
                b = md5_HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
                a = md5_HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
                d = md5_HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
                c = md5_HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
                b = md5_HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
                a = md5_HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
                d = md5_HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
                c = md5_HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
                b = md5_HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
                a = md5_II(a, b, c, d, x[k + 0], S41, 0xF4292244);
                d = md5_II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
                c = md5_II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
                b = md5_II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
                a = md5_II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
                d = md5_II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
                c = md5_II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
                b = md5_II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
                a = md5_II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
                d = md5_II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
                c = md5_II(c, d, a, b, x[k + 6], S43, 0xA3014314);
                b = md5_II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
                a = md5_II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
                d = md5_II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
                c = md5_II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
                b = md5_II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
                a = md5_AddUnsigned(a, AA);
                b = md5_AddUnsigned(b, BB);
                c = md5_AddUnsigned(c, CC);
                d = md5_AddUnsigned(d, DD);
            }
            return (md5_WordToHex(a) + md5_WordToHex(b) + md5_WordToHex(c) + md5_WordToHex(d)).toLowerCase();
        }
        
        // ==================== 密钥管理功能 ====================
        // 生成新密钥
        function generateKey() {
            const newKey = generateRandomKey();
            localStorage.setItem('textCryptKey', newKey);
            showMessage('新密钥已生成并保存!', 'success');
        }
        
        // 显示密钥
        function showKey() {
            const key = getCurrentKey();
            document.getElementById('keyText').value = key;
            document.getElementById('importKey').value = '';
            document.getElementById('keyModal').style.display = 'block';
        }
        
        // 关闭密钥模态框
        function closeKeyModal() {
            document.getElementById('keyModal').style.display = 'none';
        }
        
        // 复制密钥
        function copyKey() {
            const keyText = document.getElementById('keyText');
            keyText.select();
            document.execCommand('copy');
            showMessage('密钥已复制到剪贴板!', 'success');
        }
        
        // 保存密钥到文件
        function saveKeyToFile() {
            const key = getCurrentKey();
            const blob = new Blob([key], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'text_crypt.key';
            document.body.appendChild(a);
            a.click();
            
            // 清理
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
            
            showMessage('密钥已保存到文件!', 'success');
        }
        
        // 从文件加载密钥
        function loadKeyFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.key';
            
            input.onchange = event => {
                const file = event.target.files[0];
                const reader = new FileReader();
                
                reader.onload = e => {
                    const key = e.target.result.trim();
                    if (key.length === 64) { // 检查密钥长度
                        localStorage.setItem('textCryptKey', key);
                        showMessage('密钥已从文件加载!', 'success');
                        closeKeyModal();
                    } else {
                        showMessage('无效的密钥文件!', 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        // 导入密钥
        function importKey() {
            const key = document.getElementById('importKey').value.trim();
            if (key.length === 64) { // 检查密钥长度
                localStorage.setItem('textCryptKey', key);
                showMessage('密钥已导入!', 'success');
                closeKeyModal();
            } else {
                showMessage('无效的密钥! 密钥应该是64个字符的十六进制字符串。', 'error');
            }
        }
        
        // ==================== 通用功能 ====================
        // 显示消息
        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.innerHTML = `<p class="${type}">${text}</p>`;
            
            // 3秒后自动清除消息
            setTimeout(() => {
                messageDiv.innerHTML = '';
            }, 3000);
        }
        
        // 复制到剪贴板
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            element.select();
            document.execCommand('copy');
            showMessage('结果已复制到剪贴板!', 'success');
        }
        
        // 点击模态框外部关闭
        window.onclick = function(event) {
            const modal = document.getElementById('keyModal');
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }
        
        // ==================== 加密/解密核心函数 ====================
        // AES加密函数
        async function encrypt(plainText, keyHex) {
            // 将十六进制密钥转换为字节数组
            const keyBytes = new Uint8Array(keyHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            
            // 导入密钥
            const key = await crypto.subtle.importKey(
                'raw',
                keyBytes,
                { name: 'AES-GCM' },
                false,
                ['encrypt']
            );
            
            // 生成随机初始化向量
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            // 加密
            const encodedText = new TextEncoder().encode(plainText);
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encodedText
            );
            
            // 将IV和加密数据组合
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv, 0);
            combined.set(new Uint8Array(encrypted), iv.length);
            
            // 返回Base64编码的结果
            return btoa(String.fromCharCode(...combined));
        }
        
        // AES解密函数
        async function decrypt(encryptedText, keyHex) {
            try {
                // 将十六进制密钥转换为字节数组
                const keyBytes = new Uint8Array(keyHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                
                // 解码Base64
                const combined = new Uint8Array(atob(encryptedText).split('').map(c => c.charCodeAt(0)));
                
                // 提取IV和加密数据
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);
                
                // 导入密钥
                const key = await crypto.subtle.importKey(
                    'raw',
                    keyBytes,
                    { name: 'AES-GCM' },
                    false,
                    ['decrypt']
                );
                
                // 解密
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                
                // 返回解密后的文本
                return new TextDecoder().decode(decrypted);
            } catch (error) {
                throw new Error('解密失败，可能是密钥不正确或文本已损坏');
            }
        }
        
        // 加密 ArrayBuffer
        async function encryptArrayBuffer(plainData, keyHex) {
            // 将十六进制密钥转换为字节数组
            const keyBytes = new Uint8Array(keyHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            
            // 导入密钥
            const key = await crypto.subtle.importKey(
                'raw',
                keyBytes,
                { name: 'AES-GCM' },
                false,
                ['encrypt']
            );
            
            // 生成随机初始化向量
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            // 加密
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                plainData
            );
            
            // 将IV和加密数据组合
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv, 0);
            combined.set(new Uint8Array(encrypted), iv.length);
            
            return combined;
        }
        
        // 解密 ArrayBuffer
        async function decryptArrayBuffer(encryptedData, keyHex) {
            try {
                // 将十六进制密钥转换为字节数组
                const keyBytes = new Uint8Array(keyHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                
                // 提取IV和加密数据
                const iv = encryptedData.slice(0, 12);
                const encrypted = encryptedData.slice(12);
                
                // 导入密钥
                const key = await crypto.subtle.importKey(
                    'raw',
                    keyBytes,
                    { name: 'AES-GCM' },
                    false,
                    ['decrypt']
                );
                
                // 解密
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                
                return decrypted;
            } catch (error) {
                throw new Error('解密失败，可能是密钥不正确或文件已损坏');
            }
        }
        
        // 初始化
        initKey();
        initDragAndDrop();
        initDarkMode();
    </script>
</body>
</html>